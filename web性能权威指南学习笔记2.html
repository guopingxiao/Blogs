<!DOCTYPE html>
<html>
<head>
<title>web性能权威指南学习笔记2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
</head>
<body>
<h2>HTTP</h2>
<p>发展史 http0.9 --&gt;http1.0 --&gt;http1.1 --&gt;http2.0</p>
<blockquote>
<h3>http请求和http响应</h3>
</blockquote>
<p><img src="http://i.imgur.com/rDWdfjD.png" />
<img src="http://i.imgur.com/9ho2uij.png" /></p>
<p>主要步骤包括：</p>
<p>➊ 请求 HTML 文件，及其编码、字符集和元数据</p>
<p>➋ 对原始 HTML 请求的分块响应</p>
<p>➌ 以 ASCII 十六进制数字表示的分块数据的字节数（ 256 字节）</p>
<p>➍ 分块数据流响应结束</p>
<p>➎ 在同一个 TCP 连接上请求图标文件</p>
<p>➏ 通知服务器不再使用连接了</p>
<p>➐ 图标响应，随后关闭连接</p>
<p>啊，这一次可复杂多了。首先，最明显的差别是这里发送了两次对象请求，一次请求 HTML 页面，一次请求图片，这两次请求都是通过一个连接完成的。这个连接是持久的，因而可以重用 TCP 连接对同一主机发送多次请求，从而实现更快的用户体验。</p>
<p>为终止持久连接，客户端的第二次请求通过 Connection 首部，向服务器明确发送了关闭令牌。类似地，服务器也可以在响应完成后，通知客户端自己想要关闭当前TCP 连接。从技术角度讲，不发送这个令牌，任何一端也可以终止 TCP 连接。但为确保更好地重用连接，客户端和服务器都应该尽可能提供这个信息。</p>
<p>以上就是我们最熟悉的HTTP.1，HTTP 1.1 改变了 HTTP 协议的语义，默认使用持久连接。换句话说，除非明确告知（通过 <code>Connection: close</code> 首部），否则服务器默认会保持连接打开。</p>
<p>不过，这个功能也反向移植到了 HTTP 1.0，可以通过<code>Connection: KeepAlive</code> 首部来启用。实际上，如果你使用的是 HTTP 1.1，从技术上说不需要 <code>Connection: Keep-Alive</code> 首部，但很多客户端还是选择加上它。</p>
<blockquote>
<h3>优化方向</h3>
</blockquote>
<p>在了解更宏观的 Web 性能优化之前，先看看下面这些优化方向：</p>
<p>• 浏览器解析和优化方向；</p>
<p>• 延迟和带宽对 Web 性能的影响；</p>
<p>• 传输协议（ TCP）对 HTTP 的限制；</p>
<p>• HTTP 协议自身的功能和缺陷；</p>
<blockquote>
<h3>浏览器解析过程</h3>
</blockquote>
<p>我们得先回顾一下浏览器架构，了解一下解析、布局和脚本如何相互配合在屏幕上绘制出像素来。</p>
<p><img src="http://i.imgur.com/P9h4eHa.png" /></p>
<p>浏览器在解析 HTML 文档的基础上构建 DOM（ Document Object Model，文档对象模型）。与此同时，还有一个常常被忽略的模型——CSSOM（ CSS Object Model， CSS 对象模型），也会基于特定的样式表规则和资源构建而成。这两个模型共同创建“渲染树”，之后浏览器就有了足够的信息去进行布局，并在屏幕上绘
制图形。到目前为止，一切都很好理解。</p>
<p>然而，此时不得不提到我们最大的朋友和祸害： JavaScript。脚本执行过程中可能遇到一个同步的 document.write，从而阻塞 DOM 的解析和构建。类似地，脚本也可能查询任何对象的计算样式，从而阻塞 CSS 处理。结果， DOM 及 CSSOM的构建频繁地交织在一起： DOM 构建在 JavaScript 执行完毕前无法进行，而JavaScript 在 CSSOM 构建完成前也无法进行。</p>
<p>应用的性能，特别是首次加载时的“渲染前时间”，直接取决于标记、样式表和JavaScript 这三者之间的依赖关系。顺便说一句，还记得流行的“样式在上，脚本在下”的最佳实践吗？现在你该知道为什么了。渲染和脚本执行都会受样式表的阻塞，因此必须让 CSS 以最快的速度下载完。</p>
<p>与桌面应用相比， Web 应用不需要单独安装，只要输入 URL，按下回车键，就可以正常运行。可是，桌面应用只需要安装一次，而 Web 应用每次访问都需要走一遍“安装过程”——下载资源、构建 DOM 和 CSSOM、运行 JavaScript。正因为如此，Web 性能研究迅速发展，成为人们热议的话题也就不足为怪了。上百个资源、成兆
字节的数据、数十个不同的主机，所有这些都必须在短短几百 ms 内亲密接触一次，才能带来即刻呈现的 Web 体验。</p>
<blockquote>
<h3>速度、 性能与用户期望</h3>
</blockquote>
<p><img src="http://i.imgur.com/c6dtqAI.png" /></p>
<p>现在，把 DNS 查询，随后的 TCP 握手，以及请求网页所需的几次往返时间都算上，光网络上的延迟就能轻易突破 100~1000 ms 的预算。难怪有那么多用户，特别是那些移动或无线用户，抱怨上网速度慢了！</p>
<p>分析资源瀑布
谈到 Web 性能，必然要谈资源瀑布。<a href="http://www.webpagetest.org/">WebPageTest</a>
HTTP 请求的构成（ WebPageTest）
<img src="http://i.imgur.com/j05R7mT.png" /></p>
<p>资源瀑布图记录的是 HTTP 请求，而连接视图展示了每个 TCP 连接（这里共 30个）的生命期，这些连接用于获取 Yahoo! 主页的资源。哪里比较突出呢？注意蓝色的下载时间，很短，在每个连接的总延迟里几乎微不足道。这里总共发生了 15次 DNS 查询， 30 次 TCP 握手，还有很多等待接收每个响应第一个字节的网络延迟（绿色）。</p>
<p><img src="http://i.imgur.com/p2UvERG.png" /></p>
<p>最早渲染时间、文档完成时间和最后资源获取时间，这三个时间说明我们讨论 Web性能时有三个不同测量指标。</p>
<p>Web 应用的执行主要涉及三个任务：<strong>取得资源、页面布局和渲染、 JavaScript 执行</strong>。</p>
<p>其中，渲染和脚本执行在一个线程上交错进行，不可能并发修改生成的 DOM。实际上，优化运行时的渲染和脚本执行是至关重要的，可是，就算优化了 JavaScript 执行和渲染管道，如果浏览器因网络阻塞而等待资源到来，那结果也好不到哪里去。对运行在浏览器中的应用来说，<strong>迅速而有效地获取网络资源是第一要义。</strong></p>
<blockquote>
<h3>针对浏览器的优化建议</h3>
</blockquote>
<p>大多数浏览器都利用了如下四种技术。</p>
<p>• <strong>资源预取和排定优先次序</strong></p>
<p>文档、 CSS 和 JavaScript 解析器可以与网络协议层沟通，声明每种资源的优先级：初始渲染必需的阻塞资源具有最高优先级，而低优先级的请求可能会被临时保存在队列中。</p>
<p>• <strong>DNS预解析</strong></p>
<p>对可能的域名进行提前解析，避免将来 HTTP 请求时的 DNS 延迟。预解析可以通过学习导航历史、用户的鼠标悬停，或其他页面信号来触发。</p>
<p>• <strong>TCP预连接</strong></p>
<p>DNS 解析之后，浏览器可以根据预测的 HTTP 请求，推测性地打开 TCP 连接。如果猜对的话，则可以节省一次完整的往返（ TCP 握手）时间。</p>
<p>• <strong>页面预渲染</strong></p>
<p>某些浏览器可以让我们提示下一个可能的目标，从而在隐藏的标签页中预先渲染整个页面。这样，当用户真的触发导航时，就能立即切换过来。</p>
<p>每个页面的结构和交付：</p>
<p>• CSS 和 JavaScript 等重要资源应该尽早在文档中出现；</p>
<p>• 应该尽早交付 CSS，从而解除渲染阻塞并让 JavaScript 执行；</p>
<p>• 非关键性 JavaScript 应该推迟，以避免阻塞 DOM 和 CSSOM 构建；</p>
<p>• HTML 文档由解析器递增解析，从而保证文档可以间隙性发送，以求得最佳性能。</p>
<p>除了优化页面结构，还可以在文档中嵌入提示，以触发浏览器为我们采用其他优化机制：</p>
<pre><code>&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//hostname_to_resolve.com&quot;&gt; ➊
&lt;link rel=&quot;subresource&quot; href=&quot;/javascript/myapp.js&quot;&gt; ➋
&lt;link rel=&quot;prefetch&quot; href=&quot;/images/big.jpeg&quot;&gt; ➌
&lt;link rel=&quot;prerender&quot; href=&quot;//example.org/next_page.html&quot;&gt; ➍
</code></pre>

<p>➊ 预解析特定的域名</p>
<p>➋ 预取得页面后面要用到的关键性资源</p>
<p>➌ 预取得将来导航要用的资源</p>
<p>➍ 根据对用户下一个目标的预测，预渲染特定页面</p>
<h2>经典的性能优化最佳实践</h2>
<p>无论什么网络，也不管所用网络协议是什么版本，所有应用都应该致力于消除或减少不必要的网络延迟，将需要传输的数据压缩至最少。这两条标准是经典的性能优化最佳实践，是其他数十条性能准则的出发点。</p>
<p>• <strong>减少DNS查找</strong></p>
<p>每一次主机名解析都需要一次网络往返，从而增加请求的延迟时间，同时还会阻塞后续请求。</p>
<p>• <strong>重用TCP连接</strong></p>
<p>尽可能使用持久连接，以消除 TCP 握手和慢启动延迟；参见 2.2.2 节“慢启动”。</p>
<p>• <strong>减少HTTP重定向</strong></p>
<p>HTTP 重定向极费时间，特别是不同域名之间的重定向，更加费时；这里面既有额外的 DNS 查询、 TCP 握手，还有其他延迟。最佳的重定向次数为零。</p>
<p>• <strong>使用CDN（内容分发网络）</strong></p>
<p>把数据放到离用户地理位置更近的地方，可以显著减少每次 TCP 连接的网络延迟，增大吞吐量。这一条既适用于静态内容，也适用于动态内容；</p>
<p>• <strong>去掉不必要的资源</strong></p>
<p>任何请求都不如没有请求快。说到这，所有建议都无需解释。延迟是瓶颈，最快的速度莫过于什么也不传输。然
而， HTTP 也提供了很多额外的机制，比如缓存和压缩，还有与其版本对应的一些性能技巧。</p>
<p>• <strong>在客户端缓存资源</strong></p>
<p>应该缓存应用资源，从而避免每次请求都发送相同的内容。要说最快的网络请求，那就是不用发送请求就能获取资源。要保证首部包含适当的缓存字段：</p>
<pre><code>• Cache-Control 首部用于指定缓存时间；
• Last-Modified 和 ETag 首部提供验证机制。
</code></pre>

<p>• <strong>传输压缩过的内容</strong></p>
<p>传输前应该压缩应用资源，把要传输的字节减至最少：确保对每种要传输的资源采用最好的压缩手段。
图片一般会占到一个网页需要传输的总字节数的一半，HTML、 CSS 和 JavaScript 等文本资源的大小经过 gzip 压缩平均可以减少 60%~80%。</p>
<h2>连接与拼合</h2>
<p>最快的请求是不用请求。不管使用什么协议，也不管是什么类型的应用，减少请求次数总是最好的性能优化手段。可是，如果你无论如何也无法减少请求，那么对HTTP 1.x 而言，可以考虑把多个资源捆绑打包到一块，通过一次网络请求获取：</p>
<p>• <strong>连接</strong></p>
<p>把多个 JavaScript 或 CSS 文件组合为一个文件。</p>
<p>• <strong>拼合</strong></p>
<p>把多张图片组合为一个更大的复合的图片。</p>
<p>对 JavaScript 和 CSS 来说，只要保持一定的顺序，就可以做到把多个文件连接起来而不影响代码的行为和执行。类似地，多张图片可以组合为一个“图片精灵”，然后使用 CSS 选择这张大图中的适当部分，显示在浏览器中。</p>
<p>可是，<strong>牺牲了模块化和缓存粒度</strong>。实现这些技术也要求额外的处理、部署和编码（比如选择图片精灵中子图的 CSS 代码），因而也会给应用带来额外的复杂性。此外，把多个资源打包到一块，也可能给缓存带来负担，影响页面的执行速度。</p>
<p>• 相同类型的资源都位于一个 URL（缓存键）下面。资源包中可能包含当前页面不需要的内容。</p>
<p>• 对资源包中任何文件的更新，都要求重新下载整个资源包，导致较高的字节开销。</p>
<p>• JavaScript 和 CSS 只有在传输完成后才能被解析和执行，因而会拖慢应用的执行速度。</p>
<p>实践中，大多数 Web 应用都不是只有一个页面，而是由多个视图构成。每个视图都有自己的资源，同时资源之间还有部分重叠：公用的 CSS、 JavaScript 和图片。实际上，把所有资源都组合到一个文件经常会导致处理和加载不必要的字节。虽然可以把它看成一种预获取，但代价则是降低了初始启动的速度。</p>
<p>内存占用也会成为问题。对图片精灵来说，浏览器必须分析整个图片，即便实际上只显示了其中的一小块，也要始终把整个图片都保存在内存中。</p>
<p>在资源受限的设备，比如手机上，内存占用很快就会成为瓶颈。对于游戏等严重依赖图片的应用来说，这个问题就会更明显。</p>
<blockquote>
<h3>平衡的艺术</h3>
</blockquote>
<p>• 有选择地组合一些请求对你的应用有没有好处？</p>
<p>• 放弃缓存粒度对用户有没有负面影响？</p>
<p>• 组合图片是否会占用过多内存？</p>
<p>• 首次渲染时是否会遭遇延迟执行？</p>
<p>把首次绘制所需的 CSS 单独拿出来，优先于其他 CSS 文件发送；</p>
<h2>嵌入资源</h2>
<p>嵌入资源是另一种非常流行的优化方法，把资源嵌入文档可以减少请求的次数。比如， JavaScript 和 CSS 代码，通过适当的 script 和 style 块可以直接放在页面中，而图片甚至音频或 PDF 文件，都可以通过数据 <code>URI（ data:[mediatype][;base64],data）</code>的方式嵌入到页面中：</p>
<pre><code>&lt;img src=&quot;data:image/gif;base64,R0lGODlhAQABAIAAAAA
AAAAAACH5BAAAAAAALAAAAAABAAEAAAICTAEAOw==&quot;
alt=&quot;1x1 transparent (GIF) pixel&quot; /&gt;
</code></pre>

<p>数据 URI 适合特别小的，理想情况下，最好是只用一次的资源。嵌入资源也不是完美的方法。如果你的应用
要使用很小的、个别的文件，在考虑是否嵌入时，可以参照如下建议：</p>
<p>• 如果文件很小，而且只有个别页面使用，可以考虑嵌入；</p>
<p>• 如果文件很小，但需要在多个页面中重用，应该考虑集中打包；</p>
<p>• 如果小文件经常需要更新，就不要嵌入了；</p>

</body>
</html>
<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
